클래스 정의하는 방법

객체 만드는 방법 (new 키워드 이해하기)

메소드 정의하는 방법

생성자 정의하는 방법

this 키워드 이해하기

<br><br>

### 클래스 정의하는 방법

**클래스**

- 정의: 객체를 정의해 놓은 것
- 용도: 객체를 생성하는데 사용
- 구성요소
    - 필드(field): 해당 클래스 객체의 상태 속성 = 멤버 변수
        - 인스턴스 변수: 인스턴스가 갖는 변수. heap 영역 할당, gc에 의해 관리
        - 클래스 변수: static키워드가 인스턴스 변수 앞에 붙으면 클래스 변수. static 영역에 할당. gc의 영향x. public키워드까지 앞에 붙이면 전역 변수
    - 메서드(method): 해당 객체의 행동. 필드의 값을 조정하는데 쓰임
        - 인스턴스 메서드: 인스턴스 변수와 연관된 작업. 인스턴스를 통해 호출할 수 있으므로 반드시 먼저 인스턴스를 생성해야 함
        - 클래스 메서드(=정적 메서드): 인스턴스와 관계없는 메서드
    - 생성자(constructor): 객체가 생성된 직후에 클래스의 객체를 초기화하는 데 사용. 리턴 타입x. 클래스에 최소 한개 이상의 생성자 필수

- 초기화 블록(initializer): 조건문, 반복문 등을 사용해 명시적 초기화에선 불가능한 초기화 수행 가능
    - 클래스 초기화 블록: 클래스 변수 초기화에 쓰임
        - 기본값 → 명시적 초기화 → 클래스 초기화 블록
    - 인스턴스 초기화 블록: 인스턴스 변수 초기화에 쓰임
        - 기본값 → 명시적 초기화 → 인스턴스 초기화 블록 → 생성자

- 접근 제어자
    
    
    | 제어자 | 같은 클래스 | 같은 패키지 | 자손 클래스 | 전체 |
    | --- | --- | --- | --- | --- |
    | public | O | O | O | O |
    | protected | O | O | O |  |
    | default | O | O |  |  |
    | private | O |  |  |  |
    
- 제어자
    - abstract: 해당 클래스, 메서드에서 구현부를 가지지 않고 상속 시 구현을 강제(추상 클래스, 인터페이스에서 사용)
    - static: 해당 클래스가 인스턴스화 되어있지 않아도 사용 가능
    - final: 해당 지정자가 작성된 것에 대해 상속이나 병경 금지

- 클래스 선언
    
    ```java
    [접근제한자] [예약어] class 클래스명 {
        [접근제한자] [예약어] 자료형 변수명; // 속성값 설정
            [접근제한자] 생성자명() {}
            [접근제한자] 반환형 메소드명(매개변수) { // 기능 정의
        }
    }
    ```
    

- 클래스 명명규칙
    1. 첫 문자가 문자나 ‘_’,’$’의 특수문자로 시작, 숫자로 시작할 수 없다
    2. 자바의 키워드는 사용 불가
    3. 자바의 식별자는 대소문자를 구분
    4. 식별자 길이는 제한 없고 공백은 포함 불가


<br><br><br>



### 객체 만드는 방법 (new 키워드 이해하기)

- 클래스로부터 객체를 만드는 것: **클래스의 인스턴스화**

<br>


**객체**

- 정의: 실제로 존재하는 것. 사물 또는 개념. 속성과 기능의 집합
    - 속성(property): 멤버변수, 특성, 필드, 상태
        - ex. 크기, 길이, 높이, 색상, 볼륨, 채널 등
    - 기능(function): 메서드, 함수, 행위
        - ex. 켜기, 끄기, 볼륨 높이기, 낮추기, 채널 변경하기 등
- 용도: 객체가 가지고 있는 기능과 속성에 따라 다름
- 생성방법: **new 키워드**

<br>


**new**

```java
자료형 참조변수 = new(인스턴스 생성, 메모리할당) 자료형()(생성자 호출 및 초기화);
Tv t = new Tv();
```

- 연산자 new에 의해 Tv 클래스의 인스턴스가 메모리의 빈 공간에 생성
    - new 연산자를 통해 Heap 영역에 데이터를 저장할 공간을 할당받음
- 멤버변수(ex. color, power, channel)는 각 자료형에 해당하는 기본값으로 초기화
- 대입연산자 = 에 의해 생성된 객체의 주소값이 참조변수 t에 저장 ⇒ 참조변수 t를 통해 Tv 인스턴스에 접근(인스턴스를 다루기 위해서는 참조변수가 반드시 필요)
- 해당 클래스에 생성자 메소드가 없으면 아무런 매개변수도 없는 생성자 메소드가 자동으로 생성


<br><br><br>


### 메소드 정의하는 방법

**메서드 선언과 구현**

```java
접근제어자 리턴타입 메소드이름 (매개변수들) { // 선언부
	~ 메소드 코드 ~ // 구현부
} 

int add(int a, int b){
	int result = a + b;
	return result; // 호출한 메서드로 결과 반환
}
```

<br>

**메서드 호출**

```java
int result = add(3, 5);
```

<br>

**메서드 오버로딩**

자바는 메서드 이름이 아니라 메서드 시그니쳐로 다른 메서드들을 구분 → 같은 클래스에 있는 다른 파라미터 리스트를 가지는 동일한 이름을 갖는 메서드가 선언될 수 있음

```java
public class Order {
	public void pay(){}

	public void pay(int price){}

	public void pay(String item){}

	public void pay(int price, String item){}
}
```

<br>

**메소드를 사용하는 이유**

1. 높은 재사용성

    - 한번 만들어놓은 메소드들은 계속해서 몇 번이고 호출 가능
    - 다른 프로그램에서도 사용 가능

2. 중복된 코드의 제거

    - 프로그램을 작성할때, 반복되는 문장들을 묶어서 하나의 메소드로 작성해 놓으면, 메소드를 호출하는 한 문장으로 대체 가능
    - 전체 소스 코드의 길이 짧아짐 → 변경사항 발생 시 수정해야할 코드 줄어들어 오류 발생 가능성 줄어듬

3. 프로그램의 구조화

    - 문장을 작업 단위로 나눠 여러 개의 메서드에 담아 프로그램 구조를 단순화 시킬 수 있음 → 문제 발생 시 해당 부분을 쉽게 찾을 수 있음
