<br>
<br>

### **목차**
[산술 연산자](#산술-연산자) <br>
[비트 연산자](#비트-연산자) <br>
[관계 연산자](#관계-연산자------비교-연산자) <br>
[논리 연산자](#논리-연산자) <br>
instanceof <br>
assignment(=) operator <br>
화살표(->) 연산자 <br>
3항 연산자 <br>
연산자 우선 순위 <br>
(optional) Java 13. switch 연산자 <br>

<br><br>

### 산술 연산자(+ - * / %)

사칙 연산자(+,-,*,/)와 나머지 연산자(%)

```java
public class OperatorEx5 {
    public static void main(String[] args) {
        int a = 10;
        int b = 4;

        // + 덧셈 연산자 (정수형, 실수형 리터럴, 문자열 연산에도 사용 가능)
        System.out.printf("%d + %d = %d%n", a, b, a + b); // 10 + 4 = 14

        // - 뺄셈 연산자
        System.out.printf("%d - %d = %d%n", a, b, a - b); // 10 - 4 = 6

        // * 곱하기 연산자
        System.out.printf("%d * %d = %d%n", a, b, a * b); // 10 * 4 = 40

        // / 나누기 연산자
        System.out.printf("%d / %d = %d%n", a, b, a / b); // 10 / 4 = 2

        // / 나누기 연산자(타입이 다른 두 수)
        System.out.printf("%d / %f = %f%n", a, (float)b, a / (float)b); // 10 / 4.000000 = 2.500000

        // % 나머지 연산자
        System.out.printf("%d %% %d = %d%n", a, b, a % b); // 10 % 4 = 2

    }
}
```

- 나누기 연산자: int 타입은 소숫점 아래를 저장하지 못하므로 실수형으로 변환해 연산을 수행해야 함
    - ex. 10 / 4.0f → 10.0f / 4.0f ⇒ 2.5f
    - 연산 결과 역시 float타입
- 피연산자가 정수형인 경우 나누는 수를 0으로 사용 불가
    - 0으로 나누면 컴파일은 정상적으로 되지만 실행 시 오류(ArithmeticException) 발생
    - 실수형으로 나눌 경우 결과는 Infinity(무한대)

- 피연산자가 유한수가 아닌 경우 연산 결과
    
    
    | x | y | x/y | x%y |
    | --- | --- | --- | --- |
    | 유한수 | +-0.0 | +-Infinity | NaN |
    | 유한수 | +-Infinity | +-0.0 | x |
    | +-0.0 | +-0.0 | NaN | NaN |
    | +-Infinity | 유한수 | +-Infinity | NaN |
    | +-Infinity | +-Infinity | NaN | NaN |
    
<br><br>

### 비트 연산자(& | ^ ~ << >>)

피연산자를 비트 단위로 논리 연산. 피연산자로 실수는 허용 X, 정수(문자 포함)만 허용됨

- & (AND연산자): 피연산자 양 쪽 모두 1이어야만 1을 결과로 얻음. 그 외에는 0을 얻음
- | (OR연산자): 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻음. 그 외에는 0을 얻음
- ^ (XOR연산자): 피연산자의 값이 서로 다를 때만 1을 결과로 얻음. 같을 때는 0을 얻음
- ~ (비트전환연산자): 피연산자를 2진수로 표현했을 때 0은 1, 1은 0으로 바꿈. 논리부정연산자 !와 유사
    
    ![image](https://user-images.githubusercontent.com/93105083/162624395-3d00bfcc-0289-4031-ac06-901fe9a1066e.png)
    
    - 10진수 10을 비트전환 연산한 결과: -11
- **A<<B (쉬프트 연산자, left shift)**: A의 비트를 왼쪽으로 N만큼 이동
    - x << n은 x * $2^n$
    - 피연산자의 부호에 상관없이 각 자리를 왼쪽으로 이동시키며 빈칸을 0으로 채움
    - ex. 8 << 2 → 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동
    
    ![image](https://user-images.githubusercontent.com/93105083/162624405-22bacc8e-3445-4b66-b1d8-e12e7bc321ec.png)
    
- **A>>B (쉬프트 연산자, right shift)**: A의 비트를 오른쪽으로 N만큼 이동
    - x >> n은 x / $2^n$
    - 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 음수인 경우 빈자리를 1로 채움. 양수일 때는 0으로 채움
    
    ![image](https://user-images.githubusercontent.com/93105083/162624416-d185606a-ede4-43a8-8ba6-5064984f81c4.png)
    
- **A>>>N** (**부호가 없는 시프트 연산자, unsigned right shift):** A의 2진수를 우측으로 비트를 N만큼 이동
    - 부호를 신경쓰지 않고 모든 비트 값들을 오른쪽으로 이동시킨 후에 왼쪽의 빈 공간은 모두 0으로 채움

```java
public class OperatorEx6 {
    public static void main(String[] args) {
        int a = 15; // 1111
        int b = 6;  // 0110
        int c = -15; // 11111111111111111111111111110001
        int n = 2;

        // & AND 연산
        System.out.println("a & b = " + (a & b)); // 6 (0110)

        // | OR 연산
        System.out.println("a | b = " + (a | b)); // 15 (1111)

        // ^ XOR 연산
        System.out.println("a ^ b = " + (a ^ b)); // 9 (1001)

        // ~ 반전 연산자
        System.out.println("~c = " + ~c); // -16

        // << 시프트 연산자 (좌측으로 비트를 이동(
        System.out.println("a << n = " + (a << n)); // 60 (111100)

        // >> 시프트 연산자 (우측으로 비트를 이동)
        System.out.println("a >> n = " + (a >> n)); // 3 (0011)

        // >>> 부호가 없는 시프트 연산자
        System.out.println("a >>> n = " + (a >>> n)); // 3 (0011)
        System.out.println("c >>> n = " + (c >>> n)); // 1073741820 (00111111111111111111111111111100)
    }
}
```

<br><br>

### 관계 연산자(< > <= >= == !=, 비교 연산자)

- 연산 결과 타입: boolean
- 대소비교 연산자: < > <= >=
    - 기본형 중에서 boolean형을 제외한 나머지 자료형에 사용 가능. 참조형 사용 불가
- 등가비교 연산자: == !=
    - 기본형, 참조형 등 모든 자료형에 사용 가능

---

- == : 두 값이 같으면 true, 다르면 false
- != : 두 값이 다르면 true, 같으면 false
- A < B : B 값이 크면 true, 아니면 false
- A > B : A 값이 크면 true, 아니면 false
- A <= B : B 값이 크거나 같으면 true, 아니면 false
- A >= B : A 값이 크거나 같으면 true, 아니면 false

```java
public class OperatorEx7 {
    public static void main(String[] args) {
        int a = 12;
        int b = 5;
        int c = 12;
        String str = "5";

        // ==
        System.out.println("a == b = " + (a == b)); // a == b = false
        System.out.println("a == c = " + (a == c)); // a == c = true
        System.out.println("'A' == 'B' = " + ('A' == 'B')); // 'A' == 'B' = false

        // !=
        System.out.println("a != b = " + (a != b)); // a != b = true
        System.out.println("a != c = " + (a != c)); // a != c = false
        System.out.println("'A' != 'B' = " + ('A' != 'B')); // 'A' != 'B' = true

        // A < B
        System.out.println("a < b = " + (a < b)); // a < b = false
        System.out.println("b < a = " + (b < a)); // b < a = true

        // A > B
        System.out.println("a > b = " + (a > b)); // a > b = true
        System.out.println("b > a = " + (b > a)); // b > a = false

        // A <= B
        System.out.println("a <= b = " + (a <= b)); // a <= b = false
        System.out.println("b <= a = " + (b <= a)); // b <= a = true
        System.out.println("a <= c = " + (a <= c)); // a <= c = true

        // A >= B
        System.out.println("a >= b = " + (a >= b)); // a >= b = true
        System.out.println("b >= a = " + (b >= a)); // b >= a = false
        System.out.println("a >= c = " + (a >= c)); // a >= c = true
    }
}
```

<br><br>

### 논리 연산자(&& || !)

- && (AND 결합): 피연산자 양쪽 모두 true여야 true 결과를 얻음
- || (OR 결합): 피연산자 중 어느 한 쪽만 true여도 true 결과를 얻음
- ! (논리 부정 연산자): 피연산자가 true면 false, false면 true 반환
```java
public class OperatorEx8 {
    public static void main(String[] args) {
        int a = 10;
        int b = 10;
        int c = 5;

        // &&
        System.out.println("a == b && a > 5 = " + (a == b && a > 5)); // a == b && a > 5 = true
        System.out.println("a == b && a == 5 = " + (a == b && a == 5)); // a > b && a == 5 = false

        // ||
        System.out.println("a == b || a > 5 = " + (a == b || a > 5)); // a == b || a > 5 = true
        System.out.println("a == b || a == 5 = " + (a == b || a == 5)); // a == b || a == 5 = true

        // !
        System.out.println("a == b = " + (a == b)); // a == b = true
        System.out.println("!(a == b) = " + !(a == b)); // !(a == b) = false
    }
}
```
