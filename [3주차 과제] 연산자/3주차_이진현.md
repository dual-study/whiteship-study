**출처**

- [https://wonyong-jang.github.io/java/2020/11/18/Java-Data-Type.html](https://wonyong-jang.github.io/java/2020/11/18/Java-Data-Type.html)
- [https://coding-factory.tistory.com/521](https://coding-factory.tistory.com/521)
- [https://wonyong-jang.github.io/java/2020/11/25/Java-Operator.html](https://wonyong-jang.github.io/java/2020/11/25/Java-Operator.html)
- [https://velog.io/@jaden_94/3%EC%A3%BC%EC%B0%A8-%ED%95%AD%ED%95%B4%EC%9D%BC%EC%A7%80](https://velog.io/@jaden_94/3%EC%A3%BC%EC%B0%A8-%ED%95%AD%ED%95%B4%EC%9D%BC%EC%A7%80)
- [https://league-cat.tistory.com/415?category=720850](https://league-cat.tistory.com/415?category=720850)
- 
---
## **산술 연산자**
산술 연산자는 두개의 피연산자를 사용하여 계산을 수행하는 함수를 의미한다.
- `사칙연산(더하기, 빼기, 곱하기, 나누기) + 나머지 연산자`

|단항 연산자|설명|
|:---:|---|
|+|더하기연산자|
|-|빼기연산자|
|-|곱하기연산자|
|-|나누기연산자|
|-|나머지연산자|
```java
public class calc {
    public static void main(String[] args) {
            int a = 3;
            int b = 4;
            System.out.println(a+b); // 7
            System.out.println(a-b); // -1
            System.out.println(a/b); // 0
            System.out.println(a*b); // 12
            System.out.println(a%b); // 3
    }
}
```

<br>

## **비트 연산자**

비트연산은 1과 0을 가지고 이루어진다. 일반적으로 0이 false, 그 외의 모든 값을 true를 나타낸다.

비트 연산자는 기능에 따라 비트 이동연산자, 비트 논리연산자로 구분한다.

### *비트 이동 연산자*
|연산식|설명|
|:---:|---|
|x << y|정수 x의 각 비트를 y만큼 왼쪽으로 이동시킵니다. (빈자리는 `0`으로 채워집니다.)|
|x >> y|정수 x의 각 비트를 y만큼 오른쪽으로 이동시킵니다. (빈자리는 정수 a의 `최상위 부호비트`와 같은 값으로 채워집니다.  |
|x >>> y|정수 x의 각 비트를 y만큼 오른쪽으로 이동시킵니다. (빈자리는 `0`으로 채워집니다.)|

<br>

<img src="https://user-images.githubusercontent.com/26623547/100453169-ddbde180-30fd-11eb-918e-6a84945d018b.png" width="600px">

- 2를 32비트로 분해한 다음 왼쪽으로 3비트를 이동시킨다.
- `왼쪽 비트는 버려지고, 오른쪽 빈 공간은 0으로 채워진다.`

<br>

<img src="https://user-images.githubusercontent.com/26623547/100453179-df87a500-30fd-11eb-96e4-7a51f526ca7b.png" width="600px">

- 16을 32비트로 분해한 다음 왼쪽으로 3비트를 이동시킨다.
- `최상위 부호비트가 0이라면 동일하게 0으로 채워지고, 1이라면 1로 빈공간을 채우게 된다.`

<br>

<img src="https://user-images.githubusercontent.com/26623547/100453192-e3b3c280-30fd-11eb-96ef-0367c8483501.png" width="600px">

- 연산은 오직 자바에만 있는 연산이며 >> 와 기본원리는 같다. 
- 다른 점은 `최상위 부호비트와 관계없이 무조건 0으로만 채워지게 된다. `
- 앞자리가 0으로만 채워지므로 `결과값은 무조건 양수`로 나타난다.

### *비트 이동 연산자*
- &(AND) 연산자 : 두 비트 모두 1일 경우에만 연산 결과가 1
- (OR) 연산자: 두 비트 중 하나만 1일 경우에만 연산결과가 1
- ^(XOR) : 두 비트중 하나는 1이고 다른 하나가 0일 경우에만 연산결과가 1
- ~(NOT) : 비트 반전(보수)

|연산식|설명|
|:---:|---|
|&(AND) 연산자|두 비트 모두 1일 경우에만 연산 결과가 1|
|(OR) 연산자|두 비트 중 하나만 1일 경우에만 연산결과가 1|
|^(XOR)|두 비트중 하나는 1이고 다른 하나가 0일 경우에만 연산결과가 1|
|~(NOT)|비트 반전(보수)|

<br>

## **관계 연산자**
비교 연산자라고도 하며 부등호를 생각하면 된다. 관계연산자의 결과는 true 혹은 false 값인 boolean 자료형으로 반환이 된다.

|연산자|기능|
|:---:|---|
|<	|왼쪽 피연산자가 오른쪽 피연산자보다 작은가|
|>	|왼쪽 피연산자가 오른쪽 피연산자보다 큰가|
|<=	|왼쪽 피연산자가 오른쪽 피연산자보다 같거나 작은가|
|>=	|왼쪽 피연산자가 오른쪽 피연산자보다 같거나 큰가|
|==	|두 연산자가 같은가|
|!=	|두 연산자가 다른가|

<br>

## **논리 연산자**
논리식으로 true와 false를 판단.

|연산자|기능|
|:---:|---|
|&&	|왼쪽 연산자와 오른쪽 연산자가 모두 true이면 연산결과는 true|
|!	|기존 연산결과와 반대|

### *& 와 && , | 와 ||의 차이는 무엇일까*
```
if ( false & true )
if ( false && true ) 
```
- && 조건 일때 첫 번째 조건이 false 이면 뒤의 조건들을 생각하지 않아도 해당 조건은 false가 된다.

이 때 & 연산자를 사용하면 결과를 첫 번째 조건을 통해서 이미 알았다 하더라도 두번째 조건도 확인하는 과정을 거치고, && 연산을 사용하면 첫 번째 조건에서 해당 논리식의 값을 유추했다면 뒤의 조건들은 확인하지 않는다.

- 연산속도를 생각한다면 `&& 이나 || 이 & 와 | 보다 더 빠른 속도를 가진다.`
    - &&는 첫번째 조건이 false면 더연산을 하지않기 때문에
<br>

## **instanceof**
## **assignment(=) operator**
## **화살표(->) 연산자**
## **3항 연산자**
## **연산자 우선 순위**
## **(optional) Java 13. switch 연산자**
