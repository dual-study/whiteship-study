**출처**
- [https://wonyong-jang.github.io/java/2021/01/20/Java-Multi-Thread-Programming.html](https://wonyong-jang.github.io/java/2021/01/20/Java-Multi-Thread-Programming.html)
- [https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Process%20vs%20Thread.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Process%20vs%20Thread.md)
- [https://velog.io/@twan/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%B4%EC%A0%91](https://velog.io/@twan/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%B4%EC%A0%91)
- [https://youn12.tistory.com/33](https://youn12.tistory.com/33)
---

**학습할것(필수)**

- Thread 클래스와 Runnable 인터페이스
- 쓰레드의 상태
- 쓰레드의 우선순위
- Main 쓰레드
- 동기화
- 데드락

---
<br>

## 0. 멀티쓰레드란?
![image](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

### Process
프로그램이 메모리에 올라와 `운영체제로부터 CPU를 할당받고 프로그램이 실행되고 있는 상태`.
- 관리의 단위 (관리의 주체는 OS)
- Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역을 가지고 있다.
- 프로세스 당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
- 각 프로세스는 별도의 공간에서 실행 된다.

### Thread
스레드는 `프로세스의 실행 단위`이다.
- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.
- 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.

### Multi Thread
하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
> 한 프로세스 내부에서 개별화 된 실행 흐름을 가진 쓰레드가 여러개면 멀티 쓰레드이다.
- CPU를 효율적으로 사용할 수 있다.
- 멀티쓰레드로 인해 일어날 수 있는 문제들(동기화, 교착상태)을 잘 고려하여야 한다. 

<br>

## 1. Thread 클래스와 Runnable 인터페이스

자바에서 쓰레드를 생성하는 방법은 두가지가 있다.
1. Runnable 인터페이스 구현 
2. Thread 클래스 상속

- Runnable과 Thread 모두 `java.lang 패키지`에 포함되어 있다.
- Thread상속은 다른 클래스를 상속 받지 못하므로 일반적으로 Runnable 인터페이스를 구현하여 사용 한다.
- Runnable 인터페이스는 `run()`메소드 하나만 존재한다.

### Runnable 인터페이스 구현
Runnable 인터페이스 구현
```java
public class RunnableThread implements Runnable {
    @Override
    public void run() {
        System.out.println("Runnable Implement Thread!");
    }
}
```
실행
```java
public class Main {
    public static void main(String[] args) {
        Runnable runnable = new RunnableThread();
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```
- Runnable은 작업 내용을 가지고 있는 객체이지 실제 스레드가 아니다.
- Runnable를 매개변수로 Thread를 생성해야 스레드가 생성 된다. 
- 생성된 Thread 객체에 start()메서드로 실행 된다.

### Thread 클래스 상속
Thread 클래스 상속
```java
public class ExtendsThread extends Thread {
    public void run() {
        System.out.println("Extends Thread!");
    }
}
```
실행
```java
public class Main {
    public static void main(String[] args) {
        Thread runnable = new ExtendsThread();
        thread.start();
    }
}
```
- Thread 클래스를 상속받은 클래스를 객체로 생성 후 마찬가지로 start()로 실행한다.

<br>

### start()와 run()

start()는 쓰레드가 작업을 실행하는데 필요한 호출스택(공간)을 생성한 다음 run()을 호출해서 그 안(스택)에 run()이 저장되는 것이다.

- start()는 새로운 Thread가 생성되며 Thread가 시작되면 run() 메서드가 실행된다.
- `동일한 객체에서 두번이상 start() 호출 시 IllegalThreadStateException 예외가 발생`된다.

**run()으로만 실행 시**

`새로운 호출스택이 생성되지 않고 싱글 스레드를 이용하여 사용`하는 것이다. 

<br>

## 2. 쓰레드의 상태

- NEW : 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태
- RUNNABLE : 실행 중 또는 실행 가능한 상태
- BLOCKED : 동기화 블럭에 의해서 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)
- WAITING :  다른 스레드가 통지할 때까지 기다리는 상태
- TIMED_WAITING : 주어진 시간 동안 기다리는 상태
- TERMINATED : 쓰레드의 작업이 종료된 상태

### 스레드의 생성부터 소멸까지의 과정

![image](https://user-images.githubusercontent.com/26623547/105851281-33433b80-6026-11eb-8153-0b68ec421c78.png)

1. **쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행 대기열에 저장되어 자신의 차례가 될 때까지 기다려야 한다.** 
   - 실행 대기열은 큐와 같은 자료구조로 먼저 실행 대기열에 들어온 쓰레드가 먼저 실행된다.

2. 자기 차례가 되면 실행상태가 된다.

3. 할당된 실행시간이 다되거나 yield() 메소드를 만나면 다시 실행 대기상태가 되고 다음 쓰레드가 실행상태가 됩니다.

4. 실행 중에 suspend(), sleep(), wait(), join(), I/O block에 위해 일시정지상태가 될 수 있습니다.
- I/O block은 입출력 작업에서 발생하는 지연상태를 말합니다. 사용자의 입력을 받는 경우를 예로 들수 있습니다.

5. 지정된 일시정지시간이 다되거나, notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나 다시 실행 대기열에 저장되어 자신의 차례를 기다리게 됩니다.

6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸됩니다.

### 쓰레드의 상태와 스케줄링에 관련된 메소드

**sleep()**
- 지정된 시간동안 쓰레드를 멈추게 한다.
- 밀리세컨드, 나노 세컨드의 시간단위로 세밀하게 조정가능 하지만, 오차 발생할 수 있음.
- 항상 try-catch문으로 interruptedException을 예외처리 해줘야 한다.

**join()**
- 일정 시간 동안 특정 쓰레드가 작업하는 것을 기다리게 만드는 메서드이다. 
- sleep()과 마찬가지로 try-catch 블록으로 예외처리를 해야 한다.

**interrupt()**
- sleep()이나 join()에 의해 일시정지 상태인 쓰레드를 깨워서 실행 대기상태로 만든다.
- 그냥 중지 시키지는 않고 InterruptedException 예외를 발생시키면서 중단시킨다. sleep()과 join()메소드에서 발생한다고 했던 예외이다.

**suspend(), resume(), stop()**
- suspend() : sleep()처럼 쓰레드를 일시정지 합니다.
- resume() : suspend()에 의해 일시정지 상태에 있는 쓰레드를 실행대기 상태로 만듭니다.
- stop() : 호출되는 즉시 쓰레드가 종료됩니다.

- 이 메소드들은 모두 `Deprecated` 되었다.
    - suspend()와 stop()이 교착상태(deadlock)를 일으키기 쉽게 되어 있다.

**yield()**
- 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보하고 자신은 실행대기 상태가 된다.

**notify()**


<br>

## 3. 쓰레드의 우선순위
