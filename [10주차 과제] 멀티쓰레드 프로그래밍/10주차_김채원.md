- Thread 클래스와 Runnable 인터페이스
- 쓰레드의 상태
- 쓰레드의 우선순위
- Main 쓰레드
- 동기화
- 데드락

<br><br>

## Thread 클래스와 Runnable 인터페이스

**쓰레드를 생성하는 방법**


![Untitled](https://user-images.githubusercontent.com/93105083/171550549-d9a54b73-0f7d-4fea-9bf3-e88291a3bbc4.png)




1. `Runnable` 인터페이스 사용
2. `Thread` 클래스 사용
    - `Runnable` 인터페이스를 구현한 클래스

**사용 기준**

- `Thread` 클래스가 다른 클래스를 확장할 필요가 있을 경우 → `Runnable` 인터페이스
- 그렇지 않은 경우 → `Thread` 클래스

**쓰레드 동작 순서**

```java
public class RunMultiThreads {
    public static void main(String[] args) {
        runMultiThread();
    }

    public static void runMultiThread() {
        RunnableSample[] runnable = new RunnableSample[5];
        ThreadSample[] thread = new ThreadSample[5];
        for (int loop = 0; loop < 5; loop++) {
            runnable[loop] = new RunnableSample();
            thread[loop] = new ThreadSample();

            new Thread(runnable[loop]).start();
            thread[loop].start();
        }

        System.out.println("RunMultiThreads.runMultiThread() method is ended");
    }
}
```

**쓰레드 동작 결과**

```
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is ThreadSample's run() method.
This is ThreadSample's run() method.
This is ThreadSample's run() method.
This is ThreadSample's run() method.
This is RunnableSample's run() method.
This is RunnableSample's run() method.
RunMultiThreads.runMultiThread() method is ended
This is RunnableSample's run() method.
```

- 순서대로 동작하지 않는 것을 알 수 있음

****Thread sleep메소드****

- ****sleep메소드**** 실행 → 무한으로 실행하므로 실행 중지 필요
- `Thread.sleep()` 메소드를 사용 시 → 항상 `try-catch` 로 예외 처리 해줘야 함
    - 적어도 `InterruptedException` 으로 예외 처리 필요(sleep()이 이 예외를 던질 가능성 존재)

## 쓰레드의 상태

## 쓰레드의 우선순위

## Main 쓰레드

## 동기화

## 데드락

출처

[https://sujl95.tistory.com/63](https://sujl95.tistory.com/63)
