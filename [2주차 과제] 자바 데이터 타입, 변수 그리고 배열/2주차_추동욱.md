# 2주차 과제: 자바 데이터 타입, 변수 그리고 배열

# 목표

---

자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.

# Primitive 타입 종류와 값의 범위 그리고 기본 값

# Primitve 타입과 Reference 타입

- 기본형
    - 범위가 존재하고 기본값이 존재하여 null 을 사용하지 않음
    - Stack 메모리에 저장
    - 전역으로 선언된 변수는 컴파일러가 알아서 초기화(기본값)
        
        지역 변수에서는 직접 초기화하지 않는다면 컴파일 에러
        
- 참조형
    - 기본형을 제외한 타입들은 모두 참조형
    - 실제 값을 가지고 있는 것이 아닌 Heap 공간에 할당된 위치를 가지고 있음
    - null이 존재

# 리터럴

변하지 않는(고정된) 데이터

```java
int num = 10;
```

위와 같은 코드가 존재할 때, num이란 int형 타입의 변수에 10이란 고정된 값을 할당하였다.

여기서 10이 리터럴이란 것이다.

위의 예 말고도 true, "choo", 10.22등 여러가지 타입의 리터럴이 존재한다.

- 정수 리터럴
    
    기본 숫자(1, 2, 100 등의 10진수)만 존재하는 리터럴 사용시 int형으로 판단한다. 만약 L 혹은 ㅣ(영어, 1과 혼동이 있을 수 있음 권장 X)을 사용한다면 long형 리터럴이 된다b
    
    2진수는 0b를, 8진수는 0을, 16진수는 0x를 앞에 붙혀 리터럴을 사용할 수 있다.
    
    byte, short 타입의 변수에 가능한 순자 범위의 리터럴을 사용시에는 에러가 발생하지 않는다.
    
- 부동 소수점 리터럴
    
    float형일 경우 숫자 마지막에 F 혹은 f를 붙이고 double일 경우 D 혹은 d를 붙힌다.
    
    두가지 모두 E와 e를 사용하여 나타낼 수도 있다.
    
    ```java
    double a = 111.1d;
    double b = 1.111e2;
    //a와 b는 111.1이란 동일한 값을 나타냄
    ```
    
- 문자 및 문자열 리터럴
    
    ' ' (작은 따움표)의 경우 문자 리털이 그리고 " "(큰 따옴표)의 경우 문자열 리터럴을 나타낸다. 유니코드 형식으로도 문자와 문자열을 나타낼 수 있다.
    
    또한, 자바에서 ￦(역 슬래쉬)를 사용하여 특정 시퀀스를 나타낼 수도 있다.
    
- 숫자 + 밑줄 리터럴
    
    Java SE 7 이후 버전에서는 숫자와 _(Under bar)를 사용하여 특정 단위를 구분지을 수 있다.
    
    ```java
    int birth - 90_12_25
    ```
    
    _는 반드시 숫자 사이에만 존재할 수 있다.
    

# 변수 선언 및 초기화하는 방법

변수 선언의 경우, 해당 변수의 타입과 이름을 작성하면 해당 타입의 크기만큼 메모리가 할당된다. 또 선언시 바로 해당 변수를 초기화 할 수 있다.

```java
int number;    //선언
number = 123;  //초기화

int age = 20;  //초기화

User user1 = new User("choo",27); //User 객체 타입 선언 및 초기화 
```

만약,  선언만 하고 해당 값을 사용한다면 어떻게 될까?

바로 에러가 뜨는 것을 확인 할 수 있다.

그렇기 때문에 변수를 사용하기 위해서는 초기화는 필수이다.

# 변수의 스코프와 라이프타임

## 스코프

변수의 스코프란, 해당 변수가 영향을 끼칠 수 있는 영역을 의미한다.

즉, 변수를 할당하거나 사용하기 위해서는 해당 변수 스코프 안에서만 가능하다는 것이다.

Java는 C/C++와 동일하게 Lexical Scope를 따르고 있다.

렉시컬 스코프는 변수 혹은 메소드를 어디에 선언을 하였는가에 따라 스코프가 달라지는 것이다.

그렇기 때문에 Java에서는 여러가지 종류의 변수들이 존재한다.

- 인스턴스 변수(Non-Static) / 클래스 변수(Static)

<aside>
💡 Static 필드란?

</aside>

> 스태틱 필드를 선언하게 되면, 해당 변수/메소드는 클래스가 로딩되는 순간 한번만 인스턴스화 된다.
> 

> 그렇기 때문에 해당 객체를 생성하지 않아도 변수 혹은 메소드를 바로 사용할 수 있다.
> 

인스턴스 변수와 클래스 변수 모두 클래스 영역에 선언된 변수로 클래스 내부에서 접근이 가능하다.

```java
public class Human {
	static String type = "표유류";   //클래스 변수
	String name                    //인스턴스 변수
  int age;                       //인스턴스 변수
}
```

두 변수의 차이는 static 필드의 특징을 가지느냐 아니냐이다.

즉, type(클래스 변수)의 경우 클래스가 로딩되는 순간 한번만 인스턴스화 되기 때문에 여러 Human 객체에서 접근해도 같은 값을 표시한다.

반대로 인스턴스 변수는 객체가 생성될 때마다 따로 공간이 생기게 된다.

- 지역 변수
    
    지역( {} 중괄호)을 기준(스코프)으로 하는 변수로 일반 변수를 선언하는 것과 똑같다.
    
    ```java
    public class Human{
    	static String type = "표유류";
    	String name;
    	int age;
    	
    	boolean isAdult(){
    		int korBase = 20;      //지역 변수
    		return age >= korBase;
    	}
    }
    ```
    
    그렇다면, 아래와 같이 인스턴스/클래스 변수와 지역 변수의 이름이 같다면 어떤 상황이 벌어질까?
    
    ```java
    public class Main{
    	static int a = 1;
    	void method(){
    		int a = 5;
    		System.out.println(a);
    	}
    }
    ```
    
    답은 5가 나오게 된다.
    
    즉, 지역 변수가 인스턴스/클래스 변수보다 우선순위를 가진다.
    
    또한 다른 지역에 있는 변수는 접근이 불가능하다.
    
    ```java
    public class Main {
    	// method_A 지역 
    	void method_A() { 
    		int a = 5; 
    	} 
    	// method_B 지역 
    	void method_B() {
    	 System.out.println(a); // 접근 불가(에러 발생) 
    	} 
    }
    ```
    
- 매개 변수
    
    지역 변수와 똑같이 해당 지역 내에서만 사용이 가능하며, 인스턴스/클래스 변수보다 높은 우선 순위를 가진다.
    

## 라이프 타임

스코프가 변수에 형향을 미칠 수 있는 영역이라면, 라이프 사이클은 변수가 영향을 미칠 수 있는 시점이다.

즉, 어느 위치에 어떻게 선언되었느냐에 따라 어는 시점에 이 변수를 호출 할 수 있는가가 달라진다.

- 인스턴스 변수
    
    인스턴스가 생성될 때부터 메모리에 존재할 때 까지(GC에 의해 수거 되기 전까지) 접근 가능하다.
    
- 클래스 변수
    
    클래스가 로딩할 때 부터 프로그램이 종료 될 때까지 접근 가능하다.
    
- 지역 변수
    
    선언이 되고 초기화 될 때부터 지역이 끝날 때까지 접근이 가능하다.
    

# 타입 변환, 캐스팅 그리고 타입 프로모션

타입 변환은 어떠한 데이터 타입으로 지정된 변수를 다른 타입으로 변경하는 것을 말한다.

Cating과 Promotion으로 나누어 진다.

**Promotion**

> 묵시적 형변환
캐스팅이 자동으로 발생(업캐스팅)
작은 타입이 큰 타입으로 변환
> 

```java
class Parent{

}

class Child extends Parent{

}
```

```java
Parent p = new Child();
```

**Casting**

> 명시적 형변환
캐스팅할 내용을 적어줘야 하는 경우(다운캐스팅)
큰 타입을 작은 타입으로 변환
> 

```java
Parent p = new Child();
Child c = (Child) p;
```

- 다운 캐스팅은 업캐스팅이 발생한 이후에 작용한다.

# 1차 및 2차 배열 선언하기

배열은 동일타입의 값을 여러개 취급할 수 있는 기능이다.

인덱스라고 불리는 `[]`로 감싼 0부터 시작하는 정수를 사용하여 배열의 길이나 순서를 나타낼 수 있다.

배열도 결국은 타입에 따라 default value로 채워진다.

**1차 배열 선언하기**

```java
T[] array = new T[size];
T array[] = new T[size];
```

**2차 배열 선언하기**

```java
T[][] array = new T[size1][size2]
T array[][] = new T[size1][size2]
T[] array[] = new T[size1][size2]
```

# 타입 추론, var

타입추론은 변수의 타입을 명시적으로 적어주지 않아도 컴파일러가 변수의 타입을 대입된 리터럴로 추론하는 것이다

- var는 초기화값이 있는 지역변수로만 선언이 가능하다.
    - var는 멤버변수 또는 파라미터, 리턴타입으로 사용이 불가능하다.
- var는 키워드가 아니다.
- var는 런타임 오버헤드가 없다.
