- 인터페이스 정의하는 방법
- 인터페이스 구현하는 방법
- 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
- 인터페이스 상속
- 인터페이스의 기본 메소드 (Default Method), 자바 8
- 인터페이스의 static 메소드, 자바 8
- 인터페이스의 private 메소드, 자바 9

<br><br>

## 인터페이스 정의하는 방법

<br>

**인터페이스**

```java
interface 인터페이스이름 {
	public static final 상수이름 = 값;
	public abstract void 메서드이름();
}
```

- 기본 설계도
- 객체와 객체 사이에서 일어나는 상호 작용의 매개
- 서로 이어주는 다리 역할, 프로젝트의 설계도
- 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성
- 클래스와 다르게 **다중상속(구현)** 가능

<br>

**인터페이스 사용의 이유**

1. 개발 기간을 단축 시킬 수 있다.
    
    이러한 특징을 가진 인터페이스를 사용하면 다른 개발자들이 각각의 부분을 완성할 때까지 기다리지 않고 서로 규약만 정해두어 각자의 부분만 따로 나눠서 작성된 코드를 컴파일 할 수 있다.
    
2. 클래스간 결합도를 낮출 수 있다.
    
    코드의 종속성을 줄이고 유지보수성을 높이도록 해준다.
    
3. 표준화가 가능하다.
    
    클래스의 기본틀을 제공하여 개발자들에게 정형화된 개발을 강요할 수 있다.
    
    **→ 자바의 다형성을 극대화 하여 코드의 수정을 줄이고 유지보수성을 높인다.**

<br>

**추상클래스**

```java
abstract class 클래스이름 {
	...
	public abstract void 메서드이름();
}
```

- 미완성 설계도
- 추상 메서드를 선언하여 **상속을 통해서 자손 클래스에서 완성하도록 유도**하는 클래스
- 상속을 위한 클래스이기 때문에 객체 생성 불가
- class 앞에 "abstract" 예약어를 사용하여 상속을 통해서 구현해야한다는 것을 알려주고 추상메서드를 선언

<br>

**추상클래스 VS 인터페이스**

<br>

**공통점**

추상메서드 사용 가능

<br>

**차이점**

1. 사용의도

**`추상클래스는 IS - A "~이다".`**

**`인터페이스는 HAS - A "~을 할 수 있는".`**

- 자바 → 한개의 클래스만 상속 가능
    - 해당 클래스의 구분: 추상클래스 상속
    - 할 수 있는 기능: 인터페이스로 구현

2. 공통된 기능 사용 여부
- 모든 클래스가 인터페이스 사용 → 공통으로 필요한 기능들도 모든 클래스에서 오버라이딩하여 재정의
- 공통된 기능이 필요 → 추상클래스로 일반 메서드를 작성하여 자식 클래스에서 사용 가능
    - 만약 각각 다른 추상클래스를 상속하는데 공통된 기능이 필요하다면? → 해당 기능을 인터페이스로 작성해서 구현

<br>

**인터페이스 정의하는 방법**

1. class 대신 interface를 사용
2. 모든 변수는(상수) public static final이 붙어야하며, 생략 시 컴파일러가 자동으로 추가해줌
3. 모든 메서드는 public abstract이 붙어야하며, 생략 가능
    - 단, static 메서드와 default 메서드는 예외 (JDK 1.8부터)

```java
interface 인터페이스 {
    public static final 타입 상수 = 값;
    public abstract 메서드(매개변수);
}

public class classname implements 인터페이스
```

<br><br>

## 인터페이스 구현하는 방법

**implements** 키워드를 통해 일반 클래스에서 **인터페이스를 구현**

```java
public interface Animal {
   public void cry();
}

public class Cat implements Animal {
   @Override
   public void cry() {
      System.out.println("야옹");
   }
}

public class Dog implements Animal {
   @Override
   public void cry() {
      System.out.println("멍멍");
   }
}
```

<br><br>

## 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

```java
public class Sample {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.cry();
        cat.cry();

        // dog.name(); 사용 X
        // cat.name(); 사용 X
        ((Dog)dog).name(); // 사용 O
        ((Cat)cat).name(); // 사용 O
    }
}
```

<br><br>
<hr>

**출처**

[https://myjamong.tistory.com/150](https://myjamong.tistory.com/150)

[https://k3068.tistory.com/34](https://k3068.tistory.com/34)

[https://leegicheol.github.io/whiteship-live-study/whiteship-live-study-08-interface/](https://leegicheol.github.io/whiteship-live-study/whiteship-live-study-08-interface/)

[https://sujl95.tistory.com/60](https://sujl95.tistory.com/60)
